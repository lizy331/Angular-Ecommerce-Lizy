{"ast":null,"code":"import _asyncToGenerator from \"/Users/liziyang/Desktop/2023-layoff/Udyme-Class/Full-Stack/Angular-SpringBoot/ecommerce-project/03-frontend/angular-ecommerce/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { __rest } from './_virtual/_tslib.js';\nimport * as constants from './constants.js';\nimport { DEFAULT_MAX_CLOCK_SKEW, REFERRER_PATH_STORAGE_KEY } from './constants.js';\nimport { transactionStatus, resumeTransaction, transactionExists, introspectAuthn, postToTransaction } from './tx/api.js';\nimport { AuthTransaction } from './tx/AuthTransaction.js';\nimport { setRequestHeader } from './http/headers.js';\nimport { get, httpRequest } from './http/request.js';\nimport { clone } from './util/object.js';\nimport { toAbsoluteUrl, toQueryString } from './util/url.js';\nimport PKCE from './oidc/util/pkce.js';\nimport { closeSession, sessionExists, getSession, refreshSession, setCookieAndRedirect } from './session.js';\nimport { getOAuthUrls } from './oidc/util/oauth.js';\nimport * as features from './features.js';\nimport { isBrowser } from './features.js';\nimport { isInteractionRequiredError } from './oidc/util/errors.js';\nimport { isLoginRedirect, isInteractionRequired } from './oidc/util/loginRedirect.js';\nimport { prepareTokenParams } from './oidc/util/prepareTokenParams.js';\nimport './idx/types/api.js';\nimport './myaccount/types.js';\nimport { decodeToken } from './oidc/decodeToken.js';\nimport { revokeToken } from './oidc/revokeToken.js';\nimport { renewToken } from './oidc/renewToken.js';\nimport { renewTokensWithRefresh } from './oidc/renewTokensWithRefresh.js';\nimport { renewTokens } from './oidc/renewTokens.js';\nimport { verifyToken } from './oidc/verifyToken.js';\nimport { getUserInfo } from './oidc/getUserInfo.js';\nimport { exchangeCodeForTokens } from './oidc/exchangeCodeForTokens.js';\nimport { getWithoutPrompt } from './oidc/getWithoutPrompt.js';\nimport { getWithPopup } from './oidc/getWithPopup.js';\nimport { getWithRedirect } from './oidc/getWithRedirect.js';\nimport { parseFromUrl, parseOAuthResponseFromUrl } from './oidc/parseFromUrl.js';\nimport * as index from './crypto/index.js';\nimport * as webauthn from './crypto/webauthn.js';\nimport storageUtil from './browser/browserStorage.js';\nimport { TokenManager } from './TokenManager.js';\nimport { ServiceManager } from './ServiceManager.js';\nimport PromiseQueue from './PromiseQueue.js';\nimport fingerprint from './browser/fingerprint.js';\nimport { AuthStateManager } from './AuthStateManager.js';\nimport { StorageManager } from './StorageManager.js';\nimport TransactionManager from './TransactionManager.js';\nimport { buildOptions } from './options/index.js';\nimport { authenticate } from './idx/authenticate.js';\nimport { cancel } from './idx/cancel.js';\nimport { handleEmailVerifyCallback, isEmailVerifyCallback, parseEmailVerifyCallback, isEmailVerifyCallbackError } from './idx/emailVerify.js';\nimport { interact } from './idx/interact.js';\nimport { introspect } from './idx/introspect.js';\nimport { poll } from './idx/poll.js';\nimport { proceed, canProceed } from './idx/proceed.js';\nimport { register } from './idx/register.js';\nimport { recoverPassword } from './idx/recoverPassword.js';\nimport { handleInteractionCodeRedirect } from './idx/handleInteractionCodeRedirect.js';\nimport { startTransaction } from './idx/startTransaction.js';\nimport { unlockAccount } from './idx/unlockAccount.js';\nimport { getSavedTransactionMeta, createTransactionMeta, getTransactionMeta, saveTransactionMeta, clearTransactionMeta, isTransactionMetaValid } from './idx/transactionMeta.js';\nimport { OktaUserAgent } from './OktaUserAgent.js';\nimport Emitter from 'tiny-emitter';\nimport { makeIdxState } from './idx/idxState/index.js';\n\nclass OktaAuth {\n  constructor(args) {\n    this.features = features;\n    const options = this.options = buildOptions(args);\n    this.storageManager = new StorageManager(options.storageManager, options.cookies, options.storageUtil);\n    this.transactionManager = new TransactionManager(Object.assign({\n      storageManager: this.storageManager\n    }, options.transactionManager));\n    this._oktaUserAgent = new OktaUserAgent();\n    this.tx = {\n      status: transactionStatus.bind(null, this),\n      resume: resumeTransaction.bind(null, this),\n      exists: Object.assign(transactionExists.bind(null, this), {\n        _get: name => {\n          const storage = options.storageUtil.storage;\n          return storage.get(name);\n        }\n      }),\n      introspect: introspectAuthn.bind(null, this),\n      createTransaction: res => {\n        return new AuthTransaction(this, res);\n      },\n      postToTransaction: (url, args, options) => {\n        return postToTransaction(this, url, args, options);\n      }\n    };\n    this.pkce = {\n      DEFAULT_CODE_CHALLENGE_METHOD: PKCE.DEFAULT_CODE_CHALLENGE_METHOD,\n      generateVerifier: PKCE.generateVerifier,\n      computeChallenge: PKCE.computeChallenge\n    };\n    Object.assign(this.options.storageUtil || {}, {\n      getPKCEStorage: this.storageManager.getLegacyPKCEStorage.bind(this.storageManager),\n      getHttpCache: this.storageManager.getHttpCache.bind(this.storageManager)\n    });\n    this._pending = {\n      handleLogin: false\n    };\n\n    if (isBrowser()) {\n      this.options = Object.assign(this.options, {\n        redirectUri: toAbsoluteUrl(args.redirectUri, window.location.origin)\n      });\n    }\n\n    if (!args.maxClockSkew && args.maxClockSkew !== 0) {\n      this.options.maxClockSkew = DEFAULT_MAX_CLOCK_SKEW;\n    } else {\n      this.options.maxClockSkew = args.maxClockSkew;\n    }\n\n    this.options.ignoreLifetime = !!args.ignoreLifetime;\n    this.session = {\n      close: closeSession.bind(null, this),\n      exists: sessionExists.bind(null, this),\n      get: getSession.bind(null, this),\n      refresh: refreshSession.bind(null, this),\n      setCookieAndRedirect: setCookieAndRedirect.bind(null, this)\n    };\n    this._tokenQueue = new PromiseQueue();\n\n    const useQueue = method => {\n      return PromiseQueue.prototype.push.bind(this._tokenQueue, method, null);\n    };\n\n    const getWithRedirectFn = useQueue(getWithRedirect.bind(null, this));\n    const getWithRedirectApi = Object.assign(getWithRedirectFn, {\n      _setLocation: function (url) {\n        if (options.setLocation) {\n          options.setLocation(url);\n        } else {\n          window.location = url;\n        }\n      }\n    });\n    const parseFromUrlFn = useQueue(parseFromUrl.bind(null, this));\n    const parseFromUrlApi = Object.assign(parseFromUrlFn, {\n      _getHistory: function () {\n        return window.history;\n      },\n      _getLocation: function () {\n        return window.location;\n      },\n      _getDocument: function () {\n        return window.document;\n      }\n    });\n    this.token = {\n      prepareTokenParams: prepareTokenParams.bind(null, this),\n      exchangeCodeForTokens: exchangeCodeForTokens.bind(null, this),\n      getWithoutPrompt: getWithoutPrompt.bind(null, this),\n      getWithPopup: getWithPopup.bind(null, this),\n      getWithRedirect: getWithRedirectApi,\n      parseFromUrl: parseFromUrlApi,\n      decode: decodeToken,\n      revoke: revokeToken.bind(null, this),\n      renew: renewToken.bind(null, this),\n      renewTokensWithRefresh: renewTokensWithRefresh.bind(null, this),\n      renewTokens: renewTokens.bind(null, this),\n      getUserInfo: (accessTokenObject, idTokenObject) => {\n        return getUserInfo(this, accessTokenObject, idTokenObject);\n      },\n      verify: verifyToken.bind(null, this),\n      isLoginRedirect: isLoginRedirect.bind(null, this)\n    };\n    const toWrap = ['getWithoutPrompt', 'getWithPopup', 'revoke', 'renew', 'renewTokensWithRefresh', 'renewTokens'];\n    toWrap.forEach(key => {\n      this.token[key] = useQueue(this.token[key]);\n    });\n    const boundStartTransaction = startTransaction.bind(null, this);\n    this.idx = {\n      interact: interact.bind(null, this),\n      introspect: introspect.bind(null, this),\n      makeIdxResponse: makeIdxState.bind(null, this),\n      authenticate: authenticate.bind(null, this),\n      register: register.bind(null, this),\n      start: boundStartTransaction,\n      startTransaction: boundStartTransaction,\n      poll: poll.bind(null, this),\n      proceed: proceed.bind(null, this),\n      cancel: cancel.bind(null, this),\n      recoverPassword: recoverPassword.bind(null, this),\n      handleInteractionCodeRedirect: handleInteractionCodeRedirect.bind(null, this),\n      isInteractionRequired: isInteractionRequired.bind(null, this),\n      isInteractionRequiredError,\n      handleEmailVerifyCallback: handleEmailVerifyCallback.bind(null, this),\n      isEmailVerifyCallback,\n      parseEmailVerifyCallback,\n      isEmailVerifyCallbackError,\n      getSavedTransactionMeta: getSavedTransactionMeta.bind(null, this),\n      createTransactionMeta: createTransactionMeta.bind(null, this),\n      getTransactionMeta: getTransactionMeta.bind(null, this),\n      saveTransactionMeta: saveTransactionMeta.bind(null, this),\n      clearTransactionMeta: clearTransactionMeta.bind(null, this),\n      isTransactionMetaValid,\n      setFlow: flow => {\n        this.options.flow = flow;\n      },\n      getFlow: () => {\n        return this.options.flow;\n      },\n      canProceed: canProceed.bind(null, this),\n      unlockAccount: unlockAccount.bind(null, this)\n    };\n    this.http = {\n      setRequestHeader: setRequestHeader.bind(null, this)\n    };\n    this.fingerprint = fingerprint.bind(null, this);\n    this.emitter = new Emitter();\n    this.tokenManager = new TokenManager(this, args.tokenManager);\n    this.authStateManager = new AuthStateManager(this);\n    this.serviceManager = new ServiceManager(this, args.services);\n  }\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.serviceManager.start();\n\n      _this.tokenManager.start();\n\n      if (!_this.token.isLoginRedirect()) {\n        yield _this.authStateManager.updateAuthState();\n      }\n    })();\n  }\n\n  stop() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.tokenManager.stop();\n\n      yield _this2.serviceManager.stop();\n    })();\n  }\n\n  setHeaders(headers) {\n    this.options.headers = Object.assign({}, this.options.headers, headers);\n  }\n\n  signIn(opts) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this3.signInWithCredentials(opts);\n    })();\n  }\n\n  signInWithCredentials(opts) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      opts = clone(opts || {});\n\n      const _postToTransaction = options => {\n        delete opts.sendFingerprint;\n        return postToTransaction(_this4, '/api/v1/authn', opts, options);\n      };\n\n      if (!opts.sendFingerprint) {\n        return _postToTransaction();\n      }\n\n      return _this4.fingerprint().then(function (fingerprint) {\n        return _postToTransaction({\n          headers: {\n            'X-Device-Fingerprint': fingerprint\n          }\n        });\n      });\n    })();\n  }\n\n  signInWithRedirect(opts = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        originalUri\n      } = opts,\n            additionalParams = __rest(opts, [\"originalUri\"]);\n\n      if (_this5._pending.handleLogin) {\n        return;\n      }\n\n      _this5._pending.handleLogin = true;\n\n      try {\n        if (originalUri) {\n          _this5.setOriginalUri(originalUri);\n        }\n\n        const params = Object.assign({\n          scopes: _this5.options.scopes || ['openid', 'email', 'profile']\n        }, additionalParams);\n        yield _this5.token.getWithRedirect(params);\n      } finally {\n        _this5._pending.handleLogin = false;\n      }\n    })();\n  }\n\n  closeSession() {\n    var _this6 = this;\n\n    return this.session.close().then( /*#__PURE__*/_asyncToGenerator(function* () {\n      _this6.tokenManager.clear();\n    })).catch(function (e) {\n      if (e.name === 'AuthApiError' && e.errorCode === 'E0000007') {\n        return null;\n      }\n\n      throw e;\n    });\n  }\n\n  revokeAccessToken(accessToken) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!accessToken) {\n        accessToken = (yield _this7.tokenManager.getTokens()).accessToken;\n\n        const accessTokenKey = _this7.tokenManager.getStorageKeyByType('accessToken');\n\n        _this7.tokenManager.remove(accessTokenKey);\n      }\n\n      if (!accessToken) {\n        return Promise.resolve(null);\n      }\n\n      return _this7.token.revoke(accessToken);\n    })();\n  }\n\n  revokeRefreshToken(refreshToken) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!refreshToken) {\n        refreshToken = (yield _this8.tokenManager.getTokens()).refreshToken;\n\n        const refreshTokenKey = _this8.tokenManager.getStorageKeyByType('refreshToken');\n\n        _this8.tokenManager.remove(refreshTokenKey);\n      }\n\n      if (!refreshToken) {\n        return Promise.resolve(null);\n      }\n\n      return _this8.token.revoke(refreshToken);\n    })();\n  }\n\n  getSignOutRedirectUrl(options = {}) {\n    let {\n      idToken,\n      postLogoutRedirectUri,\n      state\n    } = options;\n\n    if (!idToken) {\n      idToken = this.tokenManager.getTokensSync().idToken;\n    }\n\n    if (!idToken) {\n      return '';\n    }\n\n    if (!postLogoutRedirectUri) {\n      postLogoutRedirectUri = this.options.postLogoutRedirectUri;\n    }\n\n    const logoutUrl = getOAuthUrls(this).logoutUrl;\n    const idTokenHint = idToken.idToken;\n    let logoutUri = logoutUrl + '?id_token_hint=' + encodeURIComponent(idTokenHint);\n\n    if (postLogoutRedirectUri) {\n      logoutUri += '&post_logout_redirect_uri=' + encodeURIComponent(postLogoutRedirectUri);\n    }\n\n    if (state) {\n      logoutUri += '&state=' + encodeURIComponent(state);\n    }\n\n    return logoutUri;\n  }\n\n  signOut(options) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      options = Object.assign({}, options);\n      var defaultUri = window.location.origin;\n      var currentUri = window.location.href;\n      var postLogoutRedirectUri = options.postLogoutRedirectUri || _this9.options.postLogoutRedirectUri || defaultUri;\n      var accessToken = options.accessToken;\n      var refreshToken = options.refreshToken;\n      var revokeAccessToken = options.revokeAccessToken !== false;\n      var revokeRefreshToken = options.revokeRefreshToken !== false;\n\n      if (revokeRefreshToken && typeof refreshToken === 'undefined') {\n        refreshToken = _this9.tokenManager.getTokensSync().refreshToken;\n      }\n\n      if (revokeAccessToken && typeof accessToken === 'undefined') {\n        accessToken = _this9.tokenManager.getTokensSync().accessToken;\n      }\n\n      if (!options.idToken) {\n        options.idToken = _this9.tokenManager.getTokensSync().idToken;\n      }\n\n      if (revokeRefreshToken && refreshToken) {\n        yield _this9.revokeRefreshToken(refreshToken);\n      }\n\n      if (revokeAccessToken && accessToken) {\n        yield _this9.revokeAccessToken(accessToken);\n      }\n\n      const logoutUri = _this9.getSignOutRedirectUrl(Object.assign(Object.assign({}, options), {\n        postLogoutRedirectUri\n      }));\n\n      if (!logoutUri) {\n        return _this9.closeSession().then(function () {\n          if (postLogoutRedirectUri === currentUri) {\n            window.location.reload();\n          } else {\n            window.location.assign(postLogoutRedirectUri);\n          }\n        });\n      } else {\n        if (options.clearTokensBeforeRedirect) {\n          _this9.tokenManager.clear();\n        } else {\n          _this9.tokenManager.addPendingRemoveFlags();\n        }\n\n        window.location.assign(logoutUri);\n      }\n    })();\n  }\n\n  webfinger(opts) {\n    var url = '/.well-known/webfinger' + toQueryString(opts);\n    var options = {\n      headers: {\n        'Accept': 'application/jrd+json'\n      }\n    };\n    return get(this, url, options);\n  }\n\n  isAuthenticated(options = {}) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        autoRenew,\n        autoRemove\n      } = _this10.tokenManager.getOptions();\n\n      const shouldRenew = options.onExpiredToken ? options.onExpiredToken === 'renew' : autoRenew;\n      const shouldRemove = options.onExpiredToken ? options.onExpiredToken === 'remove' : autoRemove;\n\n      let {\n        accessToken\n      } = _this10.tokenManager.getTokensSync();\n\n      if (accessToken && _this10.tokenManager.hasExpired(accessToken)) {\n        accessToken = undefined;\n\n        if (shouldRenew) {\n          try {\n            accessToken = yield _this10.tokenManager.renew('accessToken');\n          } catch (_a) {}\n        } else if (shouldRemove) {\n          _this10.tokenManager.remove('accessToken');\n        }\n      }\n\n      let {\n        idToken\n      } = _this10.tokenManager.getTokensSync();\n\n      if (idToken && _this10.tokenManager.hasExpired(idToken)) {\n        idToken = undefined;\n\n        if (shouldRenew) {\n          try {\n            idToken = yield _this10.tokenManager.renew('idToken');\n          } catch (_b) {}\n        } else if (shouldRemove) {\n          _this10.tokenManager.remove('idToken');\n        }\n      }\n\n      return !!(accessToken && idToken);\n    })();\n  }\n\n  getUser() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        idToken,\n        accessToken\n      } = _this11.tokenManager.getTokensSync();\n\n      return _this11.token.getUserInfo(accessToken, idToken);\n    })();\n  }\n\n  getIdToken() {\n    const {\n      idToken\n    } = this.tokenManager.getTokensSync();\n    return idToken ? idToken.idToken : undefined;\n  }\n\n  getAccessToken() {\n    const {\n      accessToken\n    } = this.tokenManager.getTokensSync();\n    return accessToken ? accessToken.accessToken : undefined;\n  }\n\n  getRefreshToken() {\n    const {\n      refreshToken\n    } = this.tokenManager.getTokensSync();\n    return refreshToken ? refreshToken.refreshToken : undefined;\n  }\n\n  storeTokensFromRedirect() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        tokens\n      } = yield _this12.token.parseFromUrl();\n\n      _this12.tokenManager.setTokens(tokens);\n    })();\n  }\n\n  setOriginalUri(originalUri, state) {\n    const sessionStorage = storageUtil.getSessionStorage();\n    sessionStorage.setItem(REFERRER_PATH_STORAGE_KEY, originalUri);\n    state = state || this.options.state;\n\n    if (state) {\n      const sharedStorage = this.storageManager.getOriginalUriStorage();\n      sharedStorage.setItem(state, originalUri);\n    }\n  }\n\n  getOriginalUri(state) {\n    state = state || this.options.state;\n\n    if (state) {\n      const sharedStorage = this.storageManager.getOriginalUriStorage();\n      const originalUri = sharedStorage.getItem(state);\n\n      if (originalUri) {\n        return originalUri;\n      }\n    }\n\n    const storage = storageUtil.getSessionStorage();\n    return storage ? storage.getItem(REFERRER_PATH_STORAGE_KEY) || undefined : undefined;\n  }\n\n  removeOriginalUri(state) {\n    const storage = storageUtil.getSessionStorage();\n    storage.removeItem(REFERRER_PATH_STORAGE_KEY);\n    state = state || this.options.state;\n\n    if (state) {\n      const sharedStorage = this.storageManager.getOriginalUriStorage();\n      sharedStorage.removeItem && sharedStorage.removeItem(state);\n    }\n  }\n\n  isLoginRedirect() {\n    return isLoginRedirect(this);\n  }\n\n  handleLoginRedirect(tokens, originalUri) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      let state = _this13.options.state;\n\n      if (tokens) {\n        _this13.tokenManager.setTokens(tokens);\n\n        originalUri = originalUri || _this13.getOriginalUri(_this13.options.state);\n      } else if (_this13.isLoginRedirect()) {\n        try {\n          const oAuthResponse = yield parseOAuthResponseFromUrl(_this13, {});\n          state = oAuthResponse.state;\n          originalUri = originalUri || _this13.getOriginalUri(state);\n          yield _this13.storeTokensFromRedirect();\n        } catch (e) {\n          yield _this13.authStateManager.updateAuthState();\n          throw e;\n        }\n      } else {\n        return;\n      }\n\n      yield _this13.authStateManager.updateAuthState();\n\n      _this13.removeOriginalUri(state);\n\n      const {\n        restoreOriginalUri\n      } = _this13.options;\n\n      if (restoreOriginalUri) {\n        yield restoreOriginalUri(_this13, originalUri);\n      } else if (originalUri) {\n        window.location.replace(originalUri);\n      }\n    })();\n  }\n\n  isPKCE() {\n    return !!this.options.pkce;\n  }\n\n  hasResponseType(responseType) {\n    let hasResponseType = false;\n\n    if (Array.isArray(this.options.responseType) && this.options.responseType.length) {\n      hasResponseType = this.options.responseType.indexOf(responseType) >= 0;\n    } else {\n      hasResponseType = this.options.responseType === responseType;\n    }\n\n    return hasResponseType;\n  }\n\n  isAuthorizationCodeFlow() {\n    return this.hasResponseType('code');\n  }\n\n  getIssuerOrigin() {\n    return this.options.issuer.split('/oauth2/')[0];\n  }\n\n  forgotPassword(opts) {\n    return postToTransaction(this, '/api/v1/authn/recovery/password', opts);\n  }\n\n  unlockAccount(opts) {\n    return postToTransaction(this, '/api/v1/authn/recovery/unlock', opts);\n  }\n\n  verifyRecoveryToken(opts) {\n    return postToTransaction(this, '/api/v1/authn/recovery/token', opts);\n  }\n\n  invokeApiMethod(options) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.accessToken) {\n        const accessToken = (yield _this14.tokenManager.getTokens()).accessToken;\n        options.accessToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.accessToken;\n      }\n\n      return httpRequest(_this14, options);\n    })();\n  }\n\n}\n\nOktaAuth.features = features;\nOktaAuth.crypto = index;\nOktaAuth.webauthn = webauthn;\nOktaAuth.features = OktaAuth.prototype.features = features;\nObject.assign(OktaAuth, {\n  constants\n});\nexport { OktaAuth as default }; //# sourceMappingURL=OktaAuth.js.map","map":null,"metadata":{},"sourceType":"module"}